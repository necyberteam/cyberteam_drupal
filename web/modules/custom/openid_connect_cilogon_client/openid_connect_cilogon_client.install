<?php

/**
 * @file
 * Install, update and uninstall functions for the OpenID Connect CILogon Client module.
 */

use Drupal\field\Entity\FieldStorageConfig;
use Drupal\field\Entity\FieldConfig;

/**
 * Implements hook_install().
 */
function openid_connect_cilogon_client_install() {
  // Create field storage for CILogon identity provider field
  if (!FieldStorageConfig::loadByName('user', 'field_cilogon_idp')) {
    FieldStorageConfig::create([
      'field_name' => 'field_cilogon_idp',
      'entity_type' => 'user',
      'type' => 'string',
      'cardinality' => 1,
      'settings' => [
        'max_length' => 255,
      ],
    ])->save();
  }

  // Create field instance on user entity
  if (!FieldConfig::loadByName('user', 'user', 'field_cilogon_idp')) {
    FieldConfig::create([
      'field_name' => 'field_cilogon_idp',
      'entity_type' => 'user',
      'bundle' => 'user',
      'label' => 'CILogon Identity Provider',
      'description' => 'The identity provider used for CILogon authentication.',
      'required' => FALSE,
      'settings' => [],
    ])->save();

    // Set field display settings
    /** @var \Drupal\Core\Entity\Display\EntityViewDisplayInterface $view_display */
    $view_display = \Drupal::entityTypeManager()
      ->getStorage('entity_view_display')
      ->load('user.user.default');

    if ($view_display) {
      $view_display->setComponent('field_cilogon_idp', [
        'type' => 'string',
        'label' => 'above',
        'weight' => 10,
      ])->save();
    }

    // Hide from form display by default
    /** @var \Drupal\Core\Entity\Display\EntityFormDisplayInterface $form_display */
    $form_display = \Drupal::entityTypeManager()
      ->getStorage('entity_form_display')
      ->load('user.user.default');

    if ($form_display) {
      $form_display->removeComponent('field_cilogon_idp')->save();
    }
  }

  \Drupal::messenger()->addStatus(t('CILogon Identity Provider field created successfully.'));
}

/**
 * Implements hook_uninstall().
 */
function openid_connect_cilogon_client_uninstall() {
  // Clean up configuration
  \Drupal::configFactory()->getEditable('openid_connect.settings.cilogon')->delete();
  \Drupal::configFactory()->getEditable('openid_connect.settings.cilogon_accessci')->delete();

  // Delete field config
  $field_config = FieldConfig::loadByName('user', 'user', 'field_cilogon_idp');
  if ($field_config) {
    $field_config->delete();
  }

  // Delete field storage
  $field_storage = FieldStorageConfig::loadByName('user', 'field_cilogon_idp');
  if ($field_storage) {
    $field_storage->delete();
  }

  \Drupal::messenger()->addStatus(t('CILogon Client module uninstalled successfully.'));
}

/**
 * Migrate cilogon_auth data to openid_connect format.
 *
 * This update migrates:
 * 1. User authmap from cilogon_auth_authmap to openid_connect_authmap
 * 2. IDP names from authmap to field_cilogon_idp user field
 * 3. Configuration from cilogon_auth.settings to openid_connect.settings
 * 
 * NOTE: Source table has duplicate users. We prefer records WITH idp_name.
 */
function openid_connect_cilogon_client_update_9001(&$sandbox) {
  $database = \Drupal::database();

  // Initialize sandbox for batch processing
  if (!isset($sandbox['progress'])) {
    // Check if old table exists
    if (!$database->schema()->tableExists('cilogon_auth_authmap')) {
      $sandbox['#finished'] = 1;
      return t('No cilogon_auth_authmap table found. Migration skipped.');
    }

    $sandbox['progress'] = 0;
    $sandbox['current_uid'] = 0;
    
    // Get DISTINCT users count (not total records, since there are duplicates)
    $sandbox['max'] = $database->query("SELECT COUNT(DISTINCT uid) FROM {cilogon_auth_authmap}")->fetchField();

    if ($sandbox['max'] == 0) {
      $sandbox['#finished'] = 1;
      return t('No records to migrate.');
    }
    
    $sandbox['skipped'] = 0;
    $sandbox['errors'] = 0;
  }

  // Process users in batches of 100
  // We select DISTINCT uids to avoid processing same user multiple times
  $batch_size = 100;
  
  // Get next batch of unique user IDs
  $query = $database->select('cilogon_auth_authmap', 'c')
    ->fields('c', ['uid'])
    ->distinct()
    ->condition('uid', $sandbox['current_uid'], '>')
    ->orderBy('uid')
    ->range(0, $batch_size);
  $uids = $query->execute()->fetchCol();

  foreach ($uids as $uid) {
    try {
      // For each user, get their record(s), preferring one WITH idp_name
      $record = $database->query("
        SELECT aid, uid, client_name, sub, idp_name 
        FROM {cilogon_auth_authmap} 
        WHERE uid = :uid 
        ORDER BY 
          CASE WHEN idp_name IS NOT NULL AND idp_name != '' THEN 0 ELSE 1 END,
          aid DESC
        LIMIT 1", [':uid' => $uid])->fetchObject();
      
      if (!$record) {
        continue;
      }

      // Check if mapping already exists in openid_connect_authmap
      $exists = $database->select('openid_connect_authmap', 'o')
        ->fields('o')
        ->condition('uid', $record->uid)
        ->condition('client_name', 'cilogon')
        ->execute()
        ->fetchField();

      if ($exists) {
        $sandbox['skipped']++;
        $sandbox['progress']++;
        $sandbox['current_uid'] = $uid;
        continue;
      }

      // Insert into openid_connect_authmap
      $database->insert('openid_connect_authmap')
        ->fields([
          'uid' => $record->uid,
          'client_name' => 'cilogon', // Map to new plugin ID
          'sub' => $record->sub,
        ])
        ->execute();

      // Store IDP name in user field if available
      if (!empty($record->idp_name)) {
        $user = \Drupal\user\Entity\User::load($record->uid);
        if ($user && $user->hasField('field_cilogon_idp')) {
          // Only update if field is empty
          if ($user->get('field_cilogon_idp')->isEmpty()) {
            $user->set('field_cilogon_idp', $record->idp_name);
            $user->save();
          }
        }
      }

      $sandbox['progress']++;
      $sandbox['current_uid'] = $uid;
    }
    catch (\Exception $e) {
      \Drupal::logger('openid_connect_cilogon_client')->error('Migration error for uid @uid: @message', [
        '@uid' => $uid,
        '@message' => $e->getMessage(),
      ]);
      $sandbox['errors']++;
      $sandbox['progress']++;
      $sandbox['current_uid'] = $uid;
    }
  }

  // Update progress
  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['progress'] / $sandbox['max']);

  if ($sandbox['#finished'] >= 1) {
    $migrated = $sandbox['progress'] - $sandbox['skipped'] - $sandbox['errors'];
    $message = t('Migrated @migrated unique users from cilogon_auth to openid_connect.', [
      '@migrated' => $migrated,
    ]);
    
    if ($sandbox['skipped'] > 0) {
      $message .= ' ' . t('Skipped @skipped existing records.', ['@skipped' => $sandbox['skipped']]);
    }
    
    if ($sandbox['errors'] > 0) {
      $message .= ' ' . t('Encountered @errors errors (see logs).', ['@errors' => $sandbox['errors']]);
    }
    
    return $message;
  }
}

/**
 * Migrate cilogon_auth configuration to openid_connect format.
 */
function openid_connect_cilogon_client_update_9002() {
  $config_factory = \Drupal::configFactory();
  
  // Load old configuration
  $old_config = $config_factory->get('cilogon_auth.settings.cilogon');
  
  if ($old_config->isNew()) {
    return t('No cilogon_auth configuration found. Skipping config migration.');
  }

  // Load new configuration
  $new_config = $config_factory->getEditable('openid_connect.settings.cilogon');

  // Map configuration values
  $mappings = [
    'settings.client_id' => 'settings.client_id',
    'settings.client_secret' => 'settings.client_secret',
    'settings.authorization_endpoint' => 'settings.authorization_endpoint',
    'settings.token_endpoint' => 'settings.token_endpoint',
    'settings.userinfo_endpoint' => 'settings.userinfo_endpoint',
  ];

  $migrated = FALSE;
  foreach ($mappings as $old_key => $new_key) {
    $value = $old_config->get($old_key);
    if (!empty($value)) {
      $new_config->set($new_key, $value);
      $migrated = TRUE;
    }
  }

  // Enable the new client if old one was enabled
  if ($old_config->get('enabled') === 'cilogon') {
    $new_config->set('enabled', TRUE);
  }

  if ($migrated) {
    $new_config->save();
    return t('Configuration migrated from cilogon_auth to openid_connect.');
  }

  return t('No configuration to migrate.');
}

/**
 * Add missing indexes to improve migration performance (optional optimization).
 */
function openid_connect_cilogon_client_update_9003() {
  $database = \Drupal::database();
  $schema = $database->schema();

  // Add index to openid_connect_authmap if it doesn't exist
  if ($schema->tableExists('openid_connect_authmap')) {
    if (!$schema->indexExists('openid_connect_authmap', 'uid_client')) {
      $schema->addIndex('openid_connect_authmap', 'uid_client', ['uid', 'client_name'], [
        'fields' => [
          'uid' => [
            'type' => 'int',
            'not null' => TRUE,
          ],
          'client_name' => [
            'type' => 'varchar',
            'length' => 255,
            'not null' => TRUE,
          ],
        ],
      ]);
      return t('Added performance index to openid_connect_authmap.');
    }
  }

  return t('Index already exists or table not found.');
}

/**
 * Re-run migration with duplicate handling.
 * 
 * The initial migration (9001) was incomplete because the source table
 * contains ~10,000 duplicate user records. This update re-processes
 * all unique users, preferring records WITH idp_name data.
 */
function openid_connect_cilogon_client_update_9004(&$sandbox) {
  $database = \Drupal::database();

  // Initialize sandbox for batch processing
  if (!isset($sandbox['progress'])) {
    // Check if old table exists
    if (!$database->schema()->tableExists('cilogon_auth_authmap')) {
      $sandbox['#finished'] = 1;
      return t('No cilogon_auth_authmap table found. Re-migration skipped.');
    }

    $sandbox['progress'] = 0;
    $sandbox['current_uid'] = 0;
    
    // Get DISTINCT users count
    $sandbox['max'] = $database->query("SELECT COUNT(DISTINCT uid) FROM {cilogon_auth_authmap}")->fetchField();

    if ($sandbox['max'] == 0) {
      $sandbox['#finished'] = 1;
      return t('No records to migrate.');
    }
    
    $sandbox['updated'] = 0;
    $sandbox['inserted'] = 0;
    $sandbox['skipped'] = 0;
    $sandbox['errors'] = 0;
  }

  // Process users in batches of 100
  $batch_size = 100;
  
  // Get next batch of unique user IDs
  // Note: MySQL doesn't support placeholders in LIMIT, so we use range()
  $query = $database->select('cilogon_auth_authmap', 'c')
    ->fields('c', ['uid'])
    ->distinct()
    ->condition('uid', $sandbox['current_uid'], '>')
    ->orderBy('uid')
    ->range(0, $batch_size);
  $uids = $query->execute()->fetchCol();

  foreach ($uids as $uid) {
    try {
      // For each user, get their BEST record (prefer one WITH idp_name)
      $record = $database->query("
        SELECT aid, uid, client_name, sub, idp_name 
        FROM {cilogon_auth_authmap} 
        WHERE uid = :uid 
        ORDER BY 
          CASE WHEN idp_name IS NOT NULL AND idp_name != '' THEN 0 ELSE 1 END,
          aid DESC
        LIMIT 1", [':uid' => $uid])->fetchObject();
      
      if (!$record) {
        $sandbox['skipped']++;
        $sandbox['progress']++;
        $sandbox['current_uid'] = $uid;
        continue;
      }

      // Check if mapping already exists
      $existing = $database->select('openid_connect_authmap', 'o')
        ->fields('o', ['aid', 'sub'])
        ->condition('uid', $record->uid)
        ->condition('client_name', 'cilogon')
        ->execute()
        ->fetchObject();

      if ($existing) {
        // Update if sub is different (handles duplicate case)
        if ($existing->sub !== $record->sub) {
          $database->update('openid_connect_authmap')
            ->fields(['sub' => $record->sub])
            ->condition('uid', $record->uid)
            ->condition('client_name', 'cilogon')
            ->execute();
          $sandbox['updated']++;
        }
        else {
          $sandbox['skipped']++;
        }
      }
      else {
        // Insert new record
        $database->insert('openid_connect_authmap')
          ->fields([
            'uid' => $record->uid,
            'client_name' => 'cilogon',
            'sub' => $record->sub,
          ])
          ->execute();
        $sandbox['inserted']++;
      }

      // Store/update IDP name in user field if available
      if (!empty($record->idp_name)) {
        $user = \Drupal\user\Entity\User::load($record->uid);
        if ($user && $user->hasField('field_cilogon_idp')) {
          $current_idp = $user->get('field_cilogon_idp')->value;
          // Update if empty or different
          if (empty($current_idp) || $current_idp !== $record->idp_name) {
            $user->set('field_cilogon_idp', $record->idp_name);
            $user->save();
          }
        }
      }

      $sandbox['progress']++;
      $sandbox['current_uid'] = $uid;
    }
    catch (\Exception $e) {
      \Drupal::logger('openid_connect_cilogon_client')->error('Re-migration error for uid @uid: @message', [
        '@uid' => $uid,
        '@message' => $e->getMessage(),
      ]);
      $sandbox['errors']++;
      $sandbox['progress']++;
      $sandbox['current_uid'] = $uid;
    }
  }

  // Update progress
  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['progress'] / $sandbox['max']);

  if ($sandbox['#finished'] >= 1) {
    $message = t('Re-migration complete: @inserted inserted, @updated updated, @skipped skipped.', [
      '@inserted' => $sandbox['inserted'],
      '@updated' => $sandbox['updated'],
      '@skipped' => $sandbox['skipped'],
    ]);
    
    if ($sandbox['errors'] > 0) {
      $message .= ' ' . t('Encountered @errors errors (see logs).', ['@errors' => $sandbox['errors']]);
    }
    
    return $message;
  }
}
